<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Color Mixer - RYB Color Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        header h2 {
            font-size: 1.1em;
            margin-bottom: 0;
            font-weight: normal;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .section h3 {
            color: #667eea;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .section p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .result {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 2px solid #667eea;
        }

        .result h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .color-swatch {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            border: 3px solid #333;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .color-info {
            flex: 1;
        }

        .color-info p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            border-color: #dc3545;
        }

        .success {
            color: #28a745;
        }

        .reference {
            grid-column: 1 / -1;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .color-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .color-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.2s;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: scaleIn 0.3s;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .color-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .color-card-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #333;
        }

        .color-card-name {
            font-weight: bold;
            color: #333;
        }

        .color-card-coord {
            color: #666;
            font-size: 0.9em;
        }

        .help-text {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #004085;
            font-size: 0.95em;
        }

        .help-text strong {
            display: block;
            margin-bottom: 5px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .reference {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Paint Color Mixer (and Un-Mixer)</h1>
            <h2>RYB Color Theory Calculator</h2>
        </header>

        <div class="main-content">
            <div class="section" style="grid-column: 1 / -1;">
                <h2>Mix and "Un-Mix" Colors</h2>
                <p style="margin-bottom: 15px;">Think of this webpage as the palette that you mix colors on and the calculator tells you what colors you get out afterward. See bottom for more information and full examples.</p>
                <div class="help-text">
                    <strong>Mixing Examples:</strong>
                    Purple + 3 Blue, [1,0,1] + [0,0,1]<br>
                    <strong>Un-Mixing Examples:</strong>
                    Brown - 0.5 Green, [2,1,1] - [1,0,0]<br>
                    <strong>Lookup Examples:</strong>
                    Persimmon-Orange, [1.5, 2.3, 1.0]
                </div>
                <div class="input-group">
                    <label for="mixInput">Enter color operation or lookup:</label>
                    <input type="text" id="mixInput" placeholder="e.g., Purple + 3 Blue, Brown - 0.5 Green, or Persimmon-Orange">
                </div>
                <div class="button-group">
                    <button onclick="processOperation()">Calculate</button>
                    <button onclick="clearMix()">Clear</button>
                </div>
                <div id="mixResult"></div>
            </div>

            <div class="section reference">
                <h2>Color Reference Guide</h2>
                <div id="colorReference"></div>
            </div>

            <div class="section reference">
                <h2>How to Use This Tool</h2>
                <div>
                    <p><strong>Note:</strong> Colors are defined by their relative proportions, so [1,0,1] appears the same color (purple) as [2,0,2], with the difference being how much "paint" there is on the palette.</p>

                    <h3>Mixing Colors</h3>
                    <p>Every A + B mixture assumes equal "mass" of A and B; an A + 2 B mixture means that there is twice as much mass in B being mixed with A (2 "portions" of B and 1 "portion" of A). For a whole portion, all of the components add up to 1; e.g., 1 portion of Violet can be normalized to be [1/8,0,7/8].</p>
                    <p><strong>Example 1:</strong> Green + Chartreuse = [0,1,1] + [0,3,1] = [0,1/2,1/2] + [0,3/4,1/4] = [0,5/4,3/4] = [0,5,3] = Lime</p>
                    <p><strong>Example 2:</strong> 3 Blue + Red = Violet = Blue + Blue + Blue + Red</p>
                    <p><strong>Example 3:</strong> 2 Orange + Blue = 2 [1/2,1/2,0] + [0,0,1] = [2,2,0] + [0,0,2] = [2,2,2] = [1,1,1] = Brown</p>

                    <h3>Un-Mixing Colors</h3>
                    <p>This tool also allows for "un-mixing"—this is the OPPOSITE of mixing. Note that for A + B = C, 1 portion of A plus 1 portion of B leads to 2 portions of C, and A + 2 B = C means that C has 3 "portions" of mass. So, C - B = A implies that C has 2 portions, and C - 2B = A implies that C has 3 units of mass.</p>
                    <p><strong>Example 1:</strong> Blue + Red = Purple, so… Purple - Blue = Red</p>
                    <p><strong>Example 2:</strong> Violet - Blue = [1/2,0,3/2] - [0,0,1] = [1/2,0,1/2] = [1,0,1] = Purple</p>
                    <p><strong>Example 3:</strong> Violet - Red = IMPOSSIBLE (since 1 portion of what + 1 portion of red = Violet? There is no such color!)</p>

                    <h3>Other Features</h3>
                    <p>• The calculator supports "names" of colors along with coordinates, so [0,0,1]+[1,0,0] is equivalent to Blue + Red.</p>
                    <p>• To look up a color, simply type its name or coordinates (e.g., "Brown" or "[1,1,1]").</p>
                    <p>• Click any color in the reference guide to see its details.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for color details -->
    <div id="colorModal" class="modal">
        <div class="modal-content">
            <div id="modalColorDetails"></div>
        </div>
    </div>

    <script>
        // Define the complete color system (Wikipedia RYB standard)
        const colors = {
            // Primary (3)
            'Red': { r: 1, y: 0, b: 0, level: 'Primary' },
            'Yellow': { r: 0, y: 1, b: 0, level: 'Primary' },
            'Blue': { r: 0, y: 0, b: 1, level: 'Primary' },

            // Secondary (3)
            'Orange': { r: 1, y: 1, b: 0, level: 'Secondary' },
            'Green': { r: 0, y: 1, b: 1, level: 'Secondary' },
            'Purple': { r: 1, y: 0, b: 1, level: 'Secondary' },

            // Brown (1) - Special mixed color
            'Brown': { r: 1, y: 1, b: 1, level: 'Brown' },

            // Tertiary (6) - Wikipedia standard
            'Vermilion': { r: 3, y: 1, b: 0, level: 'Tertiary' },
            'Amber': { r: 1, y: 3, b: 0, level: 'Tertiary' },
            'Chartreuse': { r: 0, y: 3, b: 1, level: 'Tertiary' },
            'Teal': { r: 0, y: 1, b: 3, level: 'Tertiary' },
            'Violet': { r: 1, y: 0, b: 3, level: 'Tertiary' },
            'Magenta': { r: 3, y: 0, b: 1, level: 'Tertiary' },

            // Quaternary (12) - Wikipedia standard
            'Scarlet': { r: 7, y: 1, b: 0, level: 'Quaternary' },
            'Persimmon': { r: 5, y: 3, b: 0, level: 'Quaternary' },
            'Sun': { r: 3, y: 5, b: 0, level: 'Quaternary' },
            'Golden': { r: 1, y: 7, b: 0, level: 'Quaternary' },
            'Lemon': { r: 0, y: 7, b: 1, level: 'Quaternary' },
            'Lime': { r: 0, y: 5, b: 3, level: 'Quaternary' },
            'Viridian': { r: 0, y: 3, b: 5, level: 'Quaternary' },
            'Cerulean': { r: 0, y: 1, b: 7, level: 'Quaternary' },
            'Indigo': { r: 1, y: 0, b: 7, level: 'Quaternary' },
            'Amethyst': { r: 3, y: 0, b: 5, level: 'Quaternary' },
            'Aubergine': { r: 5, y: 0, b: 3, level: 'Quaternary' },
            'Crimson': { r: 7, y: 0, b: 1, level: 'Quaternary' },

            // Quinary (24) - Descriptive hyphenated names
            'Red-Scarlet': { r: 15, y: 1, b: 0, level: 'Quinary' },
            'Scarlet-Vermilion': { r: 13, y: 3, b: 0, level: 'Quinary' },
            'Vermilion-Persimmon': { r: 11, y: 5, b: 0, level: 'Quinary' },
            'Persimmon-Orange': { r: 9, y: 7, b: 0, level: 'Quinary' },
            'Orange-Sun': { r: 7, y: 9, b: 0, level: 'Quinary' },
            'Sun-Amber': { r: 5, y: 11, b: 0, level: 'Quinary' },
            'Amber-Golden': { r: 3, y: 13, b: 0, level: 'Quinary' },
            'Golden-Yellow': { r: 1, y: 15, b: 0, level: 'Quinary' },
            'Yellow-Lemon': { r: 0, y: 15, b: 1, level: 'Quinary' },
            'Lemon-Chartreuse': { r: 0, y: 13, b: 3, level: 'Quinary' },
            'Chartreuse-Lime': { r: 0, y: 11, b: 5, level: 'Quinary' },
            'Lime-Green': { r: 0, y: 9, b: 7, level: 'Quinary' },
            'Green-Viridian': { r: 0, y: 7, b: 9, level: 'Quinary' },
            'Viridian-Teal': { r: 0, y: 5, b: 11, level: 'Quinary' },
            'Teal-Cerulean': { r: 0, y: 3, b: 13, level: 'Quinary' },
            'Cerulean-Blue': { r: 0, y: 1, b: 15, level: 'Quinary' },
            'Blue-Indigo': { r: 1, y: 0, b: 15, level: 'Quinary' },
            'Indigo-Violet': { r: 3, y: 0, b: 13, level: 'Quinary' },
            'Violet-Amethyst': { r: 5, y: 0, b: 11, level: 'Quinary' },
            'Amethyst-Purple': { r: 7, y: 0, b: 9, level: 'Quinary' },
            'Purple-Aubergine': { r: 9, y: 0, b: 7, level: 'Quinary' },
            'Aubergine-Magenta': { r: 11, y: 0, b: 5, level: 'Quinary' },
            'Magenta-Crimson': { r: 13, y: 0, b: 3, level: 'Quinary' },
            'Crimson-Red': { r: 15, y: 0, b: 1, level: 'Quinary' }
        };

        // RGB lookup table for known RYB colors
        const rybToRgbLookup = {
            // Primary
            '1,0,0': { r: 254, g: 39, b: 18 },     // Red
            '0,1,0': { r: 254, g: 221, b: 0 },     // Yellow
            '0,0,1': { r: 2, g: 71, b: 254 },      // Blue

            // Secondary
            '1,1,0': { r: 255, g: 102, b: 0 },     // Orange
            '0,1,1': { r: 0, g: 153, b: 51 },      // Green
            '1,0,1': { r: 134, g: 1, b: 175 },     // Purple

            // Brown
            '1,1,1': { r: 101, g: 67, b: 33 },     // Brown
        };

        // RYB to RGB conversion (takes Red, Yellow, Blue values)
        function rybToRgb(r, y, b) {
            const total = r + y + b;
            if (total === 0) return { r: 128, g: 128, b: 128 };

            // Normalize to simplified ratio for lookup
            const simplified = simplifyRatio(r, y, b);
            const lookupKey = `${simplified.r},${simplified.y},${simplified.b}`;

            // Check if we have an exact lookup
            if (rybToRgbLookup[lookupKey]) {
                return rybToRgbLookup[lookupKey];
            }

            // For interpolation, we'll use a better RYB to RGB conversion
            // Normalize
            const rn = r / total;
            const yn = y / total;
            const bn = b / total;

            // Improved RYB to RGB conversion using interpolation
            // Use the primary colors as anchors
            const red_rgb = { r: 254, g: 39, b: 18 };
            const yellow_rgb = { r: 254, g: 221, b: 0 };
            const blue_rgb = { r: 2, g: 71, b: 254 };

            // White point
            const white = { r: 255, g: 255, b: 255 };

            // Blend based on RYB components
            let rgb_r = white.r * (1 - rn - yn - bn);
            let rgb_g = white.g * (1 - rn - yn - bn);
            let rgb_b = white.b * (1 - rn - yn - bn);

            rgb_r += red_rgb.r * rn + yellow_rgb.r * yn + blue_rgb.r * bn;
            rgb_g += red_rgb.g * rn + yellow_rgb.g * yn + blue_rgb.g * bn;
            rgb_b += red_rgb.b * rn + yellow_rgb.b * yn + blue_rgb.b * bn;

            // Apply color mixing adjustments
            // Orange (Red + Yellow)
            if (rn > 0 && yn > 0 && bn === 0) {
                const orange = { r: 255, g: 102, b: 0 };
                const mix = Math.min(rn, yn);
                rgb_r = rgb_r * (1 - mix) + orange.r * mix;
                rgb_g = rgb_g * (1 - mix) + orange.g * mix;
                rgb_b = rgb_b * (1 - mix) + orange.b * mix;
            }
            // Green (Yellow + Blue)
            if (yn > 0 && bn > 0 && rn === 0) {
                const green = { r: 0, g: 153, b: 51 };
                const mix = Math.min(yn, bn);
                rgb_r = rgb_r * (1 - mix) + green.r * mix;
                rgb_g = rgb_g * (1 - mix) + green.g * mix;
                rgb_b = rgb_b * (1 - mix) + green.b * mix;
            }
            // Purple (Red + Blue)
            if (rn > 0 && bn > 0 && yn === 0) {
                const purple = { r: 134, g: 1, b: 175 };
                const mix = Math.min(rn, bn);
                rgb_r = rgb_r * (1 - mix) + purple.r * mix;
                rgb_g = rgb_g * (1 - mix) + purple.g * mix;
                rgb_b = rgb_b * (1 - mix) + purple.b * mix;
            }
            // Brown (Red + Yellow + Blue)
            if (rn > 0 && yn > 0 && bn > 0) {
                const brown = { r: 101, g: 67, b: 33 };
                const mix = Math.min(rn, yn, bn);
                rgb_r = rgb_r * (1 - mix) + brown.r * mix;
                rgb_g = rgb_g * (1 - mix) + brown.g * mix;
                rgb_b = rgb_b * (1 - mix) + brown.b * mix;
            }

            return {
                r: Math.min(255, Math.max(0, Math.round(rgb_r))),
                g: Math.min(255, Math.max(0, Math.round(rgb_g))),
                b: Math.min(255, Math.max(0, Math.round(rgb_b)))
            };
        }

        function rgbToHex(rgb) {
            return '#' + [rgb.r, rgb.g, rgb.b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function simplifyRatio(r, y, b) {
            const divisor = gcd(gcd(r, y), b);
            return {
                r: r / divisor,
                y: y / divisor,
                b: b / divisor
            };
        }

        // Levenshtein distance for fuzzy matching
        function levenshteinDistance(str1, str2) {
            const m = str1.length;
            const n = str2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;

            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (str1[i - 1].toLowerCase() === str2[j - 1].toLowerCase()) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = Math.min(
                            dp[i - 1][j] + 1,      // deletion
                            dp[i][j - 1] + 1,      // insertion
                            dp[i - 1][j - 1] + 1   // substitution
                        );
                    }
                }
            }

            return dp[m][n];
        }

        function findSimilarColorNames(input, maxDistance = 3) {
            const suggestions = [];

            for (let name in colors) {
                const distance = levenshteinDistance(input, name);
                if (distance <= maxDistance) {
                    suggestions.push({ name, distance });
                }
            }

            // Sort by distance (closest first)
            suggestions.sort((a, b) => a.distance - b.distance);

            return suggestions.slice(0, 3).map(s => s.name);
        }

        function parseColorInput(input) {
            input = input.trim();

            // Check if it's a color name
            for (let name in colors) {
                if (name.toLowerCase() === input.toLowerCase()) {
                    return { ...colors[name], name };
                }
            }

            // Check if it's coordinates [r,y,b] - now supports floating point
            const coordMatch = input.match(/\[?\s*(\d+(?:\.\d+)?)[,\s]+(\d+(?:\.\d+)?)[,\s]+(\d+(?:\.\d+)?)\s*\]?/);
            if (coordMatch) {
                const r = parseFloat(coordMatch[1]);
                const y = parseFloat(coordMatch[2]);
                const b = parseFloat(coordMatch[3]);

                // Validate no negative numbers
                if (r < 0 || y < 0 || b < 0) {
                    return { error: 'Coordinates cannot be negative' };
                }

                return { r, y, b };
            }

            // Check for [XR, YY, ZB] format - now supports floating point
            const labeledMatch = input.match(/\[?\s*(\d+(?:\.\d+)?)\s*R[,\s]+(\d+(?:\.\d+)?)\s*Y[,\s]+(\d+(?:\.\d+)?)\s*B\s*\]?/i);
            if (labeledMatch) {
                const r = parseFloat(labeledMatch[1]);
                const y = parseFloat(labeledMatch[2]);
                const b = parseFloat(labeledMatch[3]);

                // Validate no negative numbers
                if (r < 0 || y < 0 || b < 0) {
                    return { error: 'Coordinates cannot be negative' };
                }

                return {
                    r: r,
                    y: y,
                    b: b
                };
            }

            // If we get here, it might be a misspelled color name
            const suggestions = findSimilarColorNames(input);
            if (suggestions.length > 0) {
                return { error: `Color "${input}" not found. Did you mean: ${suggestions.join(', ')}?` };
            }

            return null;
        }

        function parseOperation(input) {
            input = input.trim();

            // Split by + and - while preserving the operators
            // Need to be careful with hyphens in color names
            const tokens = [];
            let currentTerm = '';
            let inBrackets = 0;

            for (let i = 0; i < input.length; i++) {
                const char = input[i];

                if (char === '[') inBrackets++;
                if (char === ']') inBrackets--;

                // Check if this is an operator (+ or -) outside brackets
                // For -, also check that it's preceded by a space or nothing to avoid matching hyphens in color names
                const isOperator = (char === '+' || char === '-') && inBrackets === 0 && i > 0;
                const isProbablyOperator = isOperator && (char === '+' || (char === '-' && (i === 0 || input[i-1] === ' ')));

                if (isProbablyOperator) {
                    // Found an operator outside brackets
                    tokens.push({ type: 'term', value: currentTerm.trim() });
                    tokens.push({ type: 'operator', value: char });
                    currentTerm = '';
                } else {
                    currentTerm += char;
                }
            }

            // Add the last term
            if (currentTerm.trim()) {
                tokens.push({ type: 'term', value: currentTerm.trim() });
            }

            // If only one term, treat it as a lookup
            if (tokens.length === 1 && tokens[0].type === 'term') {
                const color = parseColorTerm(tokens[0].value);
                if (!color) return null;
                return [{ type: 'color', color }];
            }

            // Must have at least one term and one operator for operations
            if (tokens.length < 3) {
                return null;
            }

            // Parse all color terms
            const operations = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].type === 'term') {
                    const color = parseColorTerm(tokens[i].value);
                    if (!color) return null;
                    operations.push({ type: 'color', color });
                } else if (tokens[i].type === 'operator') {
                    operations.push({
                        type: 'operator',
                        operator: tokens[i].value === '+' ? 'add' : 'subtract'
                    });
                }
            }

            return operations;
        }

        function parseColorTerm(term) {
            term = term.trim();

            // Check for multiplier (e.g., "2 Blue")
            const multMatch = term.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
            if (multMatch) {
                const multiplier = parseFloat(multMatch[1]);
                const color = parseColorInput(multMatch[2]);
                if (color) {
                    return {
                        r: color.r * multiplier,
                        y: color.y * multiplier,
                        b: color.b * multiplier
                    };
                }
            }

            return parseColorInput(term);
        }

        function addColors(c1, c2) {
            // Find the GCD to determine number of parts
            const parts1 = gcd(gcd(c1.r, c1.y), c1.b) || 1;
            const parts2 = gcd(gcd(c2.r, c2.y), c2.b) || 1;

            // Get base composition of one part by dividing by GCD
            const base1_r = c1.r / parts1;
            const base1_y = c1.y / parts1;
            const base1_b = c1.b / parts1;

            const base2_r = c2.r / parts2;
            const base2_y = c2.y / parts2;
            const base2_b = c2.b / parts2;

            // Calculate total mass of one part's base composition
            const totalBase1 = base1_r + base1_y + base1_b;
            const totalBase2 = base2_r + base2_y + base2_b;

            // Normalize each part to mass 1, then multiply by number of parts
            // This gives equal weight per part when mixing
            const contrib1_r = totalBase1 > 0 ? parts1 * base1_r / totalBase1 : 0;
            const contrib1_y = totalBase1 > 0 ? parts1 * base1_y / totalBase1 : 0;
            const contrib1_b = totalBase1 > 0 ? parts1 * base1_b / totalBase1 : 0;

            const contrib2_r = totalBase2 > 0 ? parts2 * base2_r / totalBase2 : 0;
            const contrib2_y = totalBase2 > 0 ? parts2 * base2_y / totalBase2 : 0;
            const contrib2_b = totalBase2 > 0 ? parts2 * base2_b / totalBase2 : 0;

            // Add contributions
            return {
                r: contrib1_r + contrib2_r,
                y: contrib1_y + contrib2_y,
                b: contrib1_b + contrib2_b
            };
        }

        function subtractColors(from, subtract) {
            // Extract number of parts using GCD
            const partsFrom = gcd(gcd(from.r, from.y), from.b) || 1;
            const partsSubtract = gcd(gcd(subtract.r, subtract.y), subtract.b) || 1;

            // Total parts in the mixture
            const totalParts = partsFrom + partsSubtract;

            // Get base composition by dividing by parts
            const baseFrom_r = from.r / partsFrom;
            const baseFrom_y = from.y / partsFrom;
            const baseFrom_b = from.b / partsFrom;

            const baseSubtract_r = subtract.r / partsSubtract;
            const baseSubtract_y = subtract.y / partsSubtract;
            const baseSubtract_b = subtract.b / partsSubtract;

            // Expand 'from' color by multiplying base by total parts
            const expanded = {
                r: baseFrom_r * totalParts,
                y: baseFrom_y * totalParts,
                b: baseFrom_b * totalParts
            };

            // Calculate m% = parts being removed / total parts
            const m_percent = partsSubtract / totalParts;

            // Calculate total mass of expanded color
            const totalMass = expanded.r + expanded.y + expanded.b;

            // Calculate mass to remove: m% of total mass, with composition matching what we're subtracting
            const massToRemove = m_percent * totalMass;
            const baseTotalSubtract = baseSubtract_r + baseSubtract_y + baseSubtract_b;

            // Check if we have enough of each component to remove what's needed
            const checks = [];
            if (baseSubtract_r > 0) {
                const amountToRemove = (baseSubtract_r / baseTotalSubtract) * massToRemove;
                checks.push({
                    color: 'Red',
                    needed: amountToRemove,
                    available: expanded.r,
                    ok: expanded.r >= amountToRemove - 0.0001  // small epsilon for floating point
                });
            }
            if (baseSubtract_y > 0) {
                const amountToRemove = (baseSubtract_y / baseTotalSubtract) * massToRemove;
                checks.push({
                    color: 'Yellow',
                    needed: amountToRemove,
                    available: expanded.y,
                    ok: expanded.y >= amountToRemove - 0.0001
                });
            }
            if (baseSubtract_b > 0) {
                const amountToRemove = (baseSubtract_b / baseTotalSubtract) * massToRemove;
                checks.push({
                    color: 'Blue',
                    needed: amountToRemove,
                    available: expanded.b,
                    ok: expanded.b >= amountToRemove - 0.0001
                });
            }

            const allOk = checks.every(c => c.ok);
            if (!allOk) {
                return { error: 'NOT POSSIBLE - insufficient color to subtract' };
            }

            // Remove mass with same composition as 'subtract'
            const result = {
                r: expanded.r - (massToRemove * baseSubtract_r / baseTotalSubtract),
                y: expanded.y - (massToRemove * baseSubtract_y / baseTotalSubtract),
                b: expanded.b - (massToRemove * baseSubtract_b / baseTotalSubtract)
            };

            return simplifyRatio(result.r, result.y, result.b);
        }

        function identifyColor(r, y, b) {
            const simplified = simplifyRatio(r, y, b);

            // Check for exact match
            for (let name in colors) {
                const c = colors[name];
                if (c.r === simplified.r && c.y === simplified.y && c.b === simplified.b) {
                    return { name, level: c.level, ...simplified };
                }
            }

            // Custom color naming system
            return identifyCustomColor(simplified.r, simplified.y, simplified.b);
        }

        function findClosestColor(r, y, b) {
            let closest = null;
            let minDistance = Infinity;

            for (let name in colors) {
                const c = colors[name];
                const distance = Math.sqrt(
                    Math.pow(c.r - r, 2) +
                    Math.pow(c.y - y, 2) +
                    Math.pow(c.b - b, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = name;
                }
            }

            return closest;
        }

        function identifyCustomColor(r, y, b) {
            // Check if color contains brown (equal parts R, Y, B)
            const minComponent = Math.min(r, y, b);

            if (minComponent > 0) {
                // Contains brown
                const brownMass = minComponent * 3; // Brown is [1,1,1]
                const leftoverR = r - minComponent;
                const leftoverY = y - minComponent;
                const leftoverB = b - minComponent;
                const leftoverMass = leftoverR + leftoverY + leftoverB;

                if (leftoverMass === 0) {
                    // Pure brown
                    return { name: 'Brown', level: 'Brown', r, y, b };
                }

                // Find the closest color to the leftover
                const leftoverColorName = findClosestColor(leftoverR, leftoverY, leftoverB);

                // Determine naming based on mass comparison
                if (leftoverMass > brownMass) {
                    // More leftover than brown: "brownish-Color"
                    return { name: `Brownish-${leftoverColorName}`, level: 'Custom', r, y, b };
                } else if (leftoverMass === brownMass) {
                    // Equal: "Color-Brown"
                    return { name: `${leftoverColorName}-Brown`, level: 'Custom', r, y, b };
                } else {
                    // More brown than leftover
                    if (brownMass >= 2 * leftoverMass) {
                        // At least 2x brown: "Shade of Brown"
                        return { name: `Shade of Brown`, level: 'Custom', r, y, b };
                    } else {
                        // Less than 2x: "Colorish-Brown"
                        return { name: `${leftoverColorName}ish-Brown`, level: 'Custom', r, y, b };
                    }
                }
            }

            // No brown - find base color (highest mass component or combination)
            // First, check if this is close to a primary color
            const total = r + y + b;

            // Try to find the dominant color(s)
            // Find all named colors and see which has the highest "mass" in this color
            let maxMass = 0;
            let baseColor = null;

            for (let name in colors) {
                const c = colors[name];
                // Calculate how many "units" of this color fit into our color
                if (c.r === 0 && c.y === 0 && c.b === 0) continue;

                const maxUnits = Math.min(
                    c.r > 0 ? r / c.r : Infinity,
                    c.y > 0 ? y / c.y : Infinity,
                    c.b > 0 ? b / c.b : Infinity
                );

                if (maxUnits > 0) {
                    const mass = maxUnits * (c.r + c.y + c.b);
                    if (mass > maxMass) {
                        maxMass = mass;
                        baseColor = name;
                    }
                }
            }

            if (baseColor) {
                const c = colors[baseColor];
                const units = Math.min(
                    c.r > 0 ? r / c.r : Infinity,
                    c.y > 0 ? y / c.y : Infinity,
                    c.b > 0 ? b / c.b : Infinity
                );

                const baseMass = units * (c.r + c.y + c.b);
                const leftoverR = r - units * c.r;
                const leftoverY = y - units * c.y;
                const leftoverB = b - units * c.b;
                const leftoverMass = leftoverR + leftoverY + leftoverB;

                if (leftoverMass < 0.001) {
                    // Essentially pure base color (shouldn't happen as we check exact matches earlier)
                    return { name: baseColor, level: 'Custom', r, y, b };
                }

                // Find closest color to the leftover
                const modifierColorName = findClosestColor(leftoverR, leftoverY, leftoverB);

                // Determine naming based on mass comparison
                if (leftoverMass > baseMass) {
                    // More modifier than base: "baseish-Modifier"
                    return { name: `${baseColor}ish-${modifierColorName}`, level: 'Custom', r, y, b };
                } else if (leftoverMass === baseMass) {
                    // Equal: "Modifier-Base"
                    return { name: `${modifierColorName}-${baseColor}`, level: 'Custom', r, y, b };
                } else {
                    // More base than modifier
                    if (baseMass >= 2 * leftoverMass) {
                        // At least 2x base: "Shade of Base"
                        return { name: `Shade of ${baseColor}`, level: 'Custom', r, y, b };
                    } else {
                        // Less than 2x: "Modifierish-Base"
                        return { name: `${modifierColorName}ish-${baseColor}`, level: 'Custom', r, y, b };
                    }
                }
            }

            // Fallback to closest match
            const closest = findClosestColor(r, y, b);
            return {
                name: `Shade of ${closest}`,
                level: 'Custom',
                r, y, b
            };
        }

        function displayResult(container, result) {
            if (result.error) {
                container.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>${result.error}</p>
                    </div>
                `;
                return;
            }

            const rgb = rybToRgb(result.r, result.y, result.b);
            const hex = rgbToHex(rgb);

            container.innerHTML = `
                <div class="result">
                    <h3>Result</h3>
                    <div class="color-display">
                        <div class="color-swatch" style="background-color: ${hex};"></div>
                        <div class="color-info">
                            <p><strong>${result.name}</strong></p>
                            <p>Level: ${result.level}</p>
                            <p>Coordinates: [${result.r}, ${result.y}, ${result.b}]</p>
                            <p>RGB: ${hex}</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function processOperation() {
            const input = document.getElementById('mixInput').value;
            const result = document.getElementById('mixResult');

            if (!input.trim()) {
                result.innerHTML = '';
                return;
            }

            const operations = parseOperation(input);
            if (!operations) {
                result.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>Invalid input. Please check your color names or coordinates.</p>
                        <p>Examples: "Blue + Red", "[1,0,1] + [0,0,1]", "Brown", "Persimmon-Orange"</p>
                    </div>
                `;
                return;
            }

            // Check if first color has an error
            if (operations[0].color.error) {
                result.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>${operations[0].color.error}</p>
                    </div>
                `;
                return;
            }

            // If only one term, it's a lookup
            if (operations.length === 1) {
                const color = operations[0].color;
                const identified = identifyColor(color.r, color.y, color.b);
                displayResult(result, identified);
                return;
            }

            // Process operations left to right
            let currentColor = operations[0].color;

            for (let i = 1; i < operations.length; i += 2) {
                const operator = operations[i];
                const nextColor = operations[i + 1].color;

                // Check for errors in the next color
                if (nextColor.error) {
                    result.innerHTML = `
                        <div class="result error">
                            <h3>Error</h3>
                            <p>${nextColor.error}</p>
                        </div>
                    `;
                    return;
                }

                if (operator.operator === 'add') {
                    currentColor = addColors(currentColor, nextColor);
                } else {
                    currentColor = subtractColors(currentColor, nextColor);
                    if (currentColor.error) {
                        displayResult(result, currentColor);
                        return;
                    }
                }
            }

            // Identify the final color
            const finalResult = identifyColor(currentColor.r, currentColor.y, currentColor.b);
            displayResult(result, finalResult);
        }

        function clearMix() {
            document.getElementById('mixInput').value = '';
            document.getElementById('mixResult').innerHTML = '';
        }

        function showColorModal(name, colorData) {
            const modal = document.getElementById('colorModal');
            const modalContent = document.getElementById('modalColorDetails');

            const rgb = rybToRgb(colorData.r, colorData.y, colorData.b);
            const hex = rgbToHex(rgb);

            modalContent.innerHTML = `
                <div class="color-display">
                    <div class="color-swatch" style="background-color: ${hex};"></div>
                    <div class="color-info">
                        <p><strong>${name}</strong></p>
                        <p>Level: ${colorData.level}</p>
                        <p>Coordinates: [${colorData.r}, ${colorData.y}, ${colorData.b}]</p>
                        <p>RGB: ${hex}</p>
                    </div>
                </div>
            `;

            modal.classList.add('active');
        }

        function closeColorModal() {
            const modal = document.getElementById('colorModal');
            modal.classList.remove('active');
        }

        function populateReference() {
            const container = document.getElementById('colorReference');
            const levels = ['Primary', 'Secondary', 'Tertiary', 'Quaternary', 'Quinary', 'Brown'];

            let html = '';
            levels.forEach(level => {
                const levelColors = Object.entries(colors).filter(([_, c]) => c.level === level);
                if (levelColors.length > 0) {
                    // For Brown, just show "Brown" without count
                    const header = level === 'Brown' ? level : `${level} Colors (${levelColors.length})`;
                    html += `<h3 style="margin-top: 20px; margin-bottom: 10px; color: #667eea;">${header}</h3>`;
                    html += '<div class="color-grid">';
                    levelColors.forEach(([name, c]) => {
                        const rgb = rybToRgb(c.r, c.y, c.b);
                        const hex = rgbToHex(rgb);
                        html += `
                            <div class="color-card" onclick="showColorModal('${name}', ${JSON.stringify(c).replace(/"/g, '&quot;')})">
                                <div class="color-card-header">
                                    <div class="color-card-swatch" style="background-color: ${hex};"></div>
                                    <div class="color-card-name">${name}</div>
                                </div>
                                <div class="color-card-coord">[${c.r}, ${c.y}, ${c.b}]</div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
            });

            container.innerHTML = html;
        }

        // Initialize
        populateReference();

        // Allow Enter key to submit
        document.getElementById('mixInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') processOperation();
        });

        // Close modal when clicking outside
        document.getElementById('colorModal').addEventListener('click', (e) => {
            if (e.target.id === 'colorModal') {
                closeColorModal();
            }
        });
    </script>
</body>
</html>
