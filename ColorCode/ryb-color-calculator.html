<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Color Mixer - RYB Color Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        header h2 {
            font-size: 1.1em;
            margin-bottom: 0;
            font-weight: normal;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .section h3 {
            color: #667eea;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .section p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .result {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 2px solid #667eea;
        }

        .result h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .color-swatch {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            border: 3px solid #333;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .color-info {
            flex: 1;
        }

        .color-info p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            border-color: #dc3545;
        }

        .success {
            color: #28a745;
        }

        .reference {
            grid-column: 1 / -1;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .color-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .color-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.2s;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: scaleIn 0.3s;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .color-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .color-card-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #333;
        }

        .color-card-name {
            font-weight: bold;
            color: #333;
        }

        .color-card-coord {
            color: #666;
            font-size: 0.9em;
        }

        .help-text {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #004085;
            font-size: 0.95em;
        }

        .help-text strong {
            display: block;
            margin-bottom: 5px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .reference {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Paint Color Mixer (and Un-Mixer)</h1>
            <h2>RYB Color Theory Calculator</h2>
        </header>

        <div class="main-content">
            <div class="section" style="grid-column: 1 / -1;">
                <h2>Mix and "Un-Mix" Colors</h2>
                <p style="margin-bottom: 15px;">Think of this webpage as the palette that you mix colors on and the calculator tells you what colors you get out afterward. See bottom for more information and full examples.</p>
                <div class="help-text">
                    <strong>Mixing Examples:</strong>
                    Purple + 3 Blue, [1,0,1] + [0,0,1]<br>
                    <strong>Un-Mixing Examples:</strong>
                    Brown - 0.5 Green, [2,1,1] - [1,0,0]<br>
                    <strong>Lookup Examples:</strong>
                    Persimmon-Orange, [1.5, 2.3, 1.0]
                </div>
                <div class="input-group">
                    <label for="mixInput">Enter color operation or lookup:</label>
                    <input type="text" id="mixInput" placeholder="e.g., Purple + 3 Blue, Brown - 0.5 Green, or Persimmon-Orange">
                </div>
                <div class="button-group">
                    <button onclick="processOperation()">Calculate</button>
                    <button onclick="clearMix()">Clear</button>
                </div>
                <div id="mixResult"></div>
            </div>

            <div class="section reference">
                <h2>Color Reference Guide</h2>
                <div id="colorReference"></div>
            </div>

            <div class="section reference">
                <h2>How to Use This Tool</h2>
                <div>
                    <p><strong>Note:</strong> Colors are defined by their relative proportions, so [1,0,1] appears the same color (purple) as [2,0,2], with the difference being how much "paint" there is on the palette.</p>

                    <h3>Mixing Colors</h3>
                    <p>Every A + B mixture assumes equal "mass" of A and B; an A + 2 B mixture means that there is twice as much mass in B being mixed with A (2 "portions" of B and 1 "portion" of A). For a whole portion, all of the components add up to 1; e.g., 1 portion of Violet can be normalized to be [1/8,0,7/8].</p>
                    <p><strong>Example 1:</strong> Green + Chartreuse = [0,1,1] + [0,3,1] = [0,1/2,1/2] + [0,3/4,1/4] = [0,5/4,3/4] = [0,5,3] = Lime</p>
                    <p><strong>Example 2:</strong> 3 Blue + Red = Violet = Blue + Blue + Blue + Red</p>
                    <p><strong>Example 3:</strong> 2 Orange + Blue = 2 [1/2,1/2,0] + [0,0,1] = [2,2,0] + [0,0,2] = [2,2,2] = [1,1,1] = Brown</p>

                    <h3>Un-Mixing Colors</h3>
                    <p>This tool also allows for "un-mixing"â€”this is the OPPOSITE of mixing. Note that for A + B = C, 1 portion of A plus 1 portion of B leads to 2 portions of C, and A + 2 B = C means that C has 3 "portions" of mass. So, C - B = A implies that C has 2 portions, and C - 2B = A implies that C has 3 units of mass.</p>
                    <p><strong>Example 1:</strong> Blue + Red = Purple, soâ€¦ Purple - Blue = Red</p>
                    <p><strong>Example 2:</strong> Violet - Blue = [1/2,0,3/2] - [0,0,1] = [1/2,0,1/2] = [1,0,1] = Purple</p>
                    <p><strong>Example 3:</strong> Violet - Red = IMPOSSIBLE (since 1 portion of what + 1 portion of red = Violet? There is no such color!)</p>

                    <h3>Other Features</h3>
                    <p>â€¢ The calculator supports "names" of colors along with coordinates, so [0,0,1]+[1,0,0] is equivalent to Blue + Red.</p>
                    <p>â€¢ To look up a color, simply type its name or coordinates (e.g., "Brown" or "[1,1,1]").</p>
                    <p>â€¢ Click any color in the reference guide to see its details.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for color details -->
    <div id="colorModal" class="modal">
        <div class="modal-content">
            <div id="modalColorDetails"></div>
        </div>
    </div>

    <script>
        // Define the complete color system (Wikipedia RYB standard)
        const colors = {
            // Primary (3)
            'Red': { r: 1, y: 0, b: 0, level: 'Primary' },
            'Yellow': { r: 0, y: 1, b: 0, level: 'Primary' },
            'Blue': { r: 0, y: 0, b: 1, level: 'Primary' },

            // Secondary (3)
            'Orange': { r: 1, y: 1, b: 0, level: 'Secondary' },
            'Green': { r: 0, y: 1, b: 1, level: 'Secondary' },
            'Purple': { r: 1, y: 0, b: 1, level: 'Secondary' },

            // Brown (1) - Special mixed color
            'Brown': { r: 1, y: 1, b: 1, level: 'Brown' },

            // Tertiary (6) - Wikipedia standard
            'Vermilion': { r: 3, y: 1, b: 0, level: 'Tertiary' },
            'Amber': { r: 1, y: 3, b: 0, level: 'Tertiary' },
            'Chartreuse': { r: 0, y: 3, b: 1, level: 'Tertiary' },
            'Teal': { r: 0, y: 1, b: 3, level: 'Tertiary' },
            'Violet': { r: 1, y: 0, b: 3, level: 'Tertiary' },
            'Magenta': { r: 3, y: 0, b: 1, level: 'Tertiary' },

            // Quaternary (12) - Wikipedia standard
            'Scarlet': { r: 7, y: 1, b: 0, level: 'Quaternary' },
            'Persimmon': { r: 5, y: 3, b: 0, level: 'Quaternary' },
            'Sun': { r: 3, y: 5, b: 0, level: 'Quaternary' },
            'Golden': { r: 1, y: 7, b: 0, level: 'Quaternary' },
            'Lemon': { r: 0, y: 7, b: 1, level: 'Quaternary' },
            'Lime': { r: 0, y: 5, b: 3, level: 'Quaternary' },
            'Viridian': { r: 0, y: 3, b: 5, level: 'Quaternary' },
            'Cerulean': { r: 0, y: 1, b: 7, level: 'Quaternary' },
            'Indigo': { r: 1, y: 0, b: 7, level: 'Quaternary' },
            'Amethyst': { r: 3, y: 0, b: 5, level: 'Quaternary' },
            'Aubergine': { r: 5, y: 0, b: 3, level: 'Quaternary' },
            'Crimson': { r: 7, y: 0, b: 1, level: 'Quaternary' },

            // Quinary (24) - Descriptive hyphenated names
            'Red-Scarlet': { r: 15, y: 1, b: 0, level: 'Quinary' },
            'Scarlet-Vermilion': { r: 13, y: 3, b: 0, level: 'Quinary' },
            'Vermilion-Persimmon': { r: 11, y: 5, b: 0, level: 'Quinary' },
            'Persimmon-Orange': { r: 9, y: 7, b: 0, level: 'Quinary' },
            'Orange-Sun': { r: 7, y: 9, b: 0, level: 'Quinary' },
            'Sun-Amber': { r: 5, y: 11, b: 0, level: 'Quinary' },
            'Amber-Golden': { r: 3, y: 13, b: 0, level: 'Quinary' },
            'Golden-Yellow': { r: 1, y: 15, b: 0, level: 'Quinary' },
            'Yellow-Lemon': { r: 0, y: 15, b: 1, level: 'Quinary' },
            'Lemon-Chartreuse': { r: 0, y: 13, b: 3, level: 'Quinary' },
            'Chartreuse-Lime': { r: 0, y: 11, b: 5, level: 'Quinary' },
            'Lime-Green': { r: 0, y: 9, b: 7, level: 'Quinary' },
            'Green-Viridian': { r: 0, y: 7, b: 9, level: 'Quinary' },
            'Viridian-Teal': { r: 0, y: 5, b: 11, level: 'Quinary' },
            'Teal-Cerulean': { r: 0, y: 3, b: 13, level: 'Quinary' },
            'Cerulean-Blue': { r: 0, y: 1, b: 15, level: 'Quinary' },
            'Blue-Indigo': { r: 1, y: 0, b: 15, level: 'Quinary' },
            'Indigo-Violet': { r: 3, y: 0, b: 13, level: 'Quinary' },
            'Violet-Amethyst': { r: 5, y: 0, b: 11, level: 'Quinary' },
            'Amethyst-Purple': { r: 7, y: 0, b: 9, level: 'Quinary' },
            'Purple-Aubergine': { r: 9, y: 0, b: 7, level: 'Quinary' },
            'Aubergine-Magenta': { r: 11, y: 0, b: 5, level: 'Quinary' },
            'Magenta-Crimson': { r: 13, y: 0, b: 3, level: 'Quinary' },
            'Crimson-Red': { r: 15, y: 0, b: 1, level: 'Quinary' }
        };

        // RGB lookup table for known RYB colors
        const rybToRgbLookup = {
            // Primary
            '1,0,0': { r: 254, g: 39, b: 18 },     // Red
            '0,1,0': { r: 254, g: 221, b: 0 },     // Yellow
            '0,0,1': { r: 2, g: 71, b: 254 },      // Blue

            // Secondary
            '1,1,0': { r: 255, g: 102, b: 0 },     // Orange
            '0,1,1': { r: 0, g: 153, b: 51 },      // Green
            '1,0,1': { r: 134, g: 1, b: 175 },     // Purple

            // Brown
            '1,1,1': { r: 101, g: 67, b: 33 },     // Brown
        };

        // RYB to RGB conversion (takes Red, Yellow, Blue values)
        function rybToRgb(r, y, b) {
            const total = r + y + b;
            if (total === 0) return { r: 128, g: 128, b: 128 };

            // Normalize to simplified ratio for lookup
            const simplified = simplifyRatio(r, y, b);
            const lookupKey = `${simplified.r},${simplified.y},${simplified.b}`;

            // Check if we have an exact lookup
            if (rybToRgbLookup[lookupKey]) {
                return rybToRgbLookup[lookupKey];
            }

            // For interpolation, we'll use a better RYB to RGB conversion
            // Normalize
            const rn = r / total;
            const yn = y / total;
            const bn = b / total;

            // Improved RYB to RGB conversion using interpolation
            // Use the primary colors as anchors
            const red_rgb = { r: 254, g: 39, b: 18 };
            const yellow_rgb = { r: 254, g: 221, b: 0 };
            const blue_rgb = { r: 2, g: 71, b: 254 };

            // White point
            const white = { r: 255, g: 255, b: 255 };

            // Blend based on RYB components
            let rgb_r = white.r * (1 - rn - yn - bn);
            let rgb_g = white.g * (1 - rn - yn - bn);
            let rgb_b = white.b * (1 - rn - yn - bn);

            rgb_r += red_rgb.r * rn + yellow_rgb.r * yn + blue_rgb.r * bn;
            rgb_g += red_rgb.g * rn + yellow_rgb.g * yn + blue_rgb.g * bn;
            rgb_b += red_rgb.b * rn + yellow_rgb.b * yn + blue_rgb.b * bn;

            // Apply color mixing adjustments
            // Orange (Red + Yellow)
            if (rn > 0 && yn > 0 && bn === 0) {
                const orange = { r: 255, g: 102, b: 0 };
                const mix = Math.min(rn, yn);
                rgb_r = rgb_r * (1 - mix) + orange.r * mix;
                rgb_g = rgb_g * (1 - mix) + orange.g * mix;
                rgb_b = rgb_b * (1 - mix) + orange.b * mix;
            }
            // Green (Yellow + Blue)
            if (yn > 0 && bn > 0 && rn === 0) {
                const green = { r: 0, g: 153, b: 51 };
                const mix = Math.min(yn, bn);
                rgb_r = rgb_r * (1 - mix) + green.r * mix;
                rgb_g = rgb_g * (1 - mix) + green.g * mix;
                rgb_b = rgb_b * (1 - mix) + green.b * mix;
            }
            // Purple (Red + Blue)
            if (rn > 0 && bn > 0 && yn === 0) {
                const purple = { r: 134, g: 1, b: 175 };
                const mix = Math.min(rn, bn);
                rgb_r = rgb_r * (1 - mix) + purple.r * mix;
                rgb_g = rgb_g * (1 - mix) + purple.g * mix;
                rgb_b = rgb_b * (1 - mix) + purple.b * mix;
            }
            // Brown (Red + Yellow + Blue)
            if (rn > 0 && yn > 0 && bn > 0) {
                const brown = { r: 101, g: 67, b: 33 };
                const mix = Math.min(rn, yn, bn);
                rgb_r = rgb_r * (1 - mix) + brown.r * mix;
                rgb_g = rgb_g * (1 - mix) + brown.g * mix;
                rgb_b = rgb_b * (1 - mix) + brown.b * mix;
            }

            return {
                r: Math.min(255, Math.max(0, Math.round(rgb_r))),
                g: Math.min(255, Math.max(0, Math.round(rgb_g))),
                b: Math.min(255, Math.max(0, Math.round(rgb_b)))
            };
        }

        function rgbToHex(rgb) {
            return '#' + [rgb.r, rgb.g, rgb.b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // ============================================
        // FRACTION ARITHMETIC SYSTEM
        // ============================================
        
        class Fraction {
            constructor(numerator, denominator = 1) {
                if (denominator === 0) {
                    throw new Error('Denominator cannot be zero');
                }
                
                // Handle negative denominators
                if (denominator < 0) {
                    numerator = -numerator;
                    denominator = -denominator;
                }
                
                // Simplify immediately
                const g = Fraction.gcd(Math.abs(numerator), Math.abs(denominator));
                this.num = numerator / g;
                this.den = denominator / g;
            }
            
            static gcd(a, b) {
                a = Math.floor(Math.abs(a));
                b = Math.floor(Math.abs(b));
                while (b !== 0) {
                    const temp = b;
                    b = a % b;
                    a = temp;
                }
                return a || 1;
            }
            
            static lcm(a, b) {
                return Math.abs(a * b) / Fraction.gcd(a, b);
            }
            
            // Convert decimal to fraction with reasonable precision
            static fromDecimal(decimal) {
                const precision = 1000000;
                const num = Math.round(decimal * precision);
                return new Fraction(num, precision);
            }
            
            // Parse fraction string like "1/3" or decimal like "0.5"
            static parse(str) {
                str = str.trim();
                
                // Check for fraction notation "1/3"
                const fractionMatch = str.match(/^(-?\d+)\s*\/\s*(\d+)$/);
                if (fractionMatch) {
                    return new Fraction(parseInt(fractionMatch[1]), parseInt(fractionMatch[2]));
                }
                
                // Check for decimal
                const decimal = parseFloat(str);
                if (!isNaN(decimal)) {
                    return Fraction.fromDecimal(decimal);
                }
                
                return null;
            }
            
            add(other) {
                const newDen = Fraction.lcm(this.den, other.den);
                const newNum = this.num * (newDen / this.den) + other.num * (newDen / other.den);
                return new Fraction(newNum, newDen);
            }
            
            subtract(other) {
                const newDen = Fraction.lcm(this.den, other.den);
                const newNum = this.num * (newDen / this.den) - other.num * (newDen / other.den);
                return new Fraction(newNum, newDen);
            }
            
            multiply(other) {
                return new Fraction(this.num * other.num, this.den * other.den);
            }
            
            divide(other) {
                return new Fraction(this.num * other.den, this.den * other.num);
            }
            
            toDecimal() {
                return this.num / this.den;
            }
            
            toString() {
                if (this.den === 1) return `${this.num}`;
                return `${this.num}/${this.den}`;
            }
            
            equals(other) {
                return this.num === other.num && this.den === other.den;
            }
            
            isZero() {
                return this.num === 0;
            }
        }
        
        // Color represented as fractions
        class FractionColor {
            constructor(r, y, b) {
                this.r = r instanceof Fraction ? r : new Fraction(r);
                this.y = y instanceof Fraction ? y : new Fraction(y);
                this.b = b instanceof Fraction ? b : new Fraction(b);
            }
            
            // Convert to simple ratio for display [r, y, b]
            toRatio() {
                // Find common denominator
                const commonDen = Fraction.lcm(
                    Fraction.lcm(this.r.den, this.y.den),
                    this.b.den
                );
                
                const r_scaled = this.r.num * (commonDen / this.r.den);
                const y_scaled = this.y.num * (commonDen / this.y.den);
                const b_scaled = this.b.num * (commonDen / this.b.den);
                
                // Simplify by GCD
                const g = Fraction.gcd(Fraction.gcd(Math.abs(r_scaled), Math.abs(y_scaled)), Math.abs(b_scaled));
                
                return {
                    r: r_scaled / g,
                    y: y_scaled / g,
                    b: b_scaled / g
                };
            }
            
            add(other) {
                return new FractionColor(
                    this.r.add(other.r),
                    this.y.add(other.y),
                    this.b.add(other.b)
                );
            }
            
            subtract(other) {
                return new FractionColor(
                    this.r.subtract(other.r),
                    this.y.subtract(other.y),
                    this.b.subtract(other.b)
                );
            }
            
            multiply(fraction) {
                if (!(fraction instanceof Fraction)) {
                    fraction = new Fraction(fraction);
                }
                return new FractionColor(
                    this.r.multiply(fraction),
                    this.y.multiply(fraction),
                    this.b.multiply(fraction)
                );
            }
        }

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function simplifyRatio(r, y, b) {
            // Convert to integers by finding a common multiplier
            // This handles cases like [1.5, 2.5, 0] -> [3, 5, 0]
            const precision = 1000000; // Handle up to 6 decimal places
            let r_int = Math.round(r * precision);
            let y_int = Math.round(y * precision);
            let b_int = Math.round(b * precision);
            
            // Find GCD of the integer versions
            const divisor = gcd(gcd(r_int, y_int), b_int);
            
            // Simplify
            r_int = r_int / divisor;
            y_int = y_int / divisor;
            b_int = b_int / divisor;
            
            return {
                r: r_int,
                y: y_int,
                b: b_int
            };
        }

        // Levenshtein distance for fuzzy matching
        function levenshteinDistance(str1, str2) {
            const m = str1.length;
            const n = str2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;

            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (str1[i - 1].toLowerCase() === str2[j - 1].toLowerCase()) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = Math.min(
                            dp[i - 1][j] + 1,      // deletion
                            dp[i][j - 1] + 1,      // insertion
                            dp[i - 1][j - 1] + 1   // substitution
                        );
                    }
                }
            }

            return dp[m][n];
        }

        function findSimilarColorNames(input, maxDistance = 3) {
            const suggestions = [];

            for (let name in colors) {
                const distance = levenshteinDistance(input, name);
                if (distance <= maxDistance) {
                    suggestions.push({ name, distance });
                }
            }

            // Sort by distance (closest first)
            suggestions.sort((a, b) => a.distance - b.distance);

            return suggestions.slice(0, 3).map(s => s.name);
        }

        function parseColorInput(input) {
            input = input.trim();

            // Check if it's a color name
            for (let name in colors) {
                if (name.toLowerCase() === input.toLowerCase()) {
                    return { ...colors[name], name };
                }
            }

            // Check if it's coordinates [r,y,b] - now supports floating point
            const coordMatch = input.match(/\[?\s*(\d+(?:\.\d+)?)[,\s]+(\d+(?:\.\d+)?)[,\s]+(\d+(?:\.\d+)?)\s*\]?/);
            if (coordMatch) {
                const r = parseFloat(coordMatch[1]);
                const y = parseFloat(coordMatch[2]);
                const b = parseFloat(coordMatch[3]);

                // Validate no negative numbers
                if (r < 0 || y < 0 || b < 0) {
                    return { error: 'Coordinates cannot be negative' };
                }

                return { r, y, b };
            }

            // Check for [XR, YY, ZB] format - now supports floating point
            const labeledMatch = input.match(/\[?\s*(\d+(?:\.\d+)?)\s*R[,\s]+(\d+(?:\.\d+)?)\s*Y[,\s]+(\d+(?:\.\d+)?)\s*B\s*\]?/i);
            if (labeledMatch) {
                const r = parseFloat(labeledMatch[1]);
                const y = parseFloat(labeledMatch[2]);
                const b = parseFloat(labeledMatch[3]);

                // Validate no negative numbers
                if (r < 0 || y < 0 || b < 0) {
                    return { error: 'Coordinates cannot be negative' };
                }

                return {
                    r: r,
                    y: y,
                    b: b
                };
            }

            // If we get here, it might be a misspelled color name
            const suggestions = findSimilarColorNames(input);
            if (suggestions.length > 0) {
                return { error: `Color "${input}" not found. Did you mean: ${suggestions.join(', ')}?` };
            }

            return null;
        }

        function parseOperation(input) {
            input = input.trim();

            // Split by + and - while preserving the operators
            // Need to be careful with hyphens in color names
            const tokens = [];
            let currentTerm = '';
            let inBrackets = 0;

            for (let i = 0; i < input.length; i++) {
                const char = input[i];

                if (char === '[') inBrackets++;
                if (char === ']') inBrackets--;

                // Check if this is an operator (+ or -) outside brackets
                // For -, also check that it's preceded by a space or nothing to avoid matching hyphens in color names
                const isOperator = (char === '+' || char === '-') && inBrackets === 0 && i > 0;
                const isProbablyOperator = isOperator && (char === '+' || (char === '-' && (i === 0 || input[i-1] === ' ')));

                if (isProbablyOperator) {
                    // Found an operator outside brackets
                    tokens.push({ type: 'term', value: currentTerm.trim() });
                    tokens.push({ type: 'operator', value: char });
                    currentTerm = '';
                } else {
                    currentTerm += char;
                }
            }

            // Add the last term
            if (currentTerm.trim()) {
                tokens.push({ type: 'term', value: currentTerm.trim() });
            }

            // If only one term, treat it as a lookup
            if (tokens.length === 1 && tokens[0].type === 'term') {
                const color = parseColorTerm(tokens[0].value);
                if (!color) return null;
                return [{ type: 'color', color }];
            }

            // Must have at least one term and one operator for operations
            if (tokens.length < 3) {
                return null;
            }

            // Parse all color terms
            const operations = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].type === 'term') {
                    const color = parseColorTerm(tokens[i].value);
                    if (!color) return null;
                    operations.push({ type: 'color', color });
                } else if (tokens[i].type === 'operator') {
                    operations.push({
                        type: 'operator',
                        operator: tokens[i].value === '+' ? 'add' : 'subtract'
                    });
                }
            }

            return operations;
        }

        function parseColorTerm(term) {
            term = term.trim();

            // Check for fraction multiplier (e.g., "1/3 Blue", "2/5 Yellow")
            const fracMatch = term.match(/^(-?\d+)\s*\/\s*(\d+)\s+(.+)$/);
            if (fracMatch) {
                const multiplier = new Fraction(parseInt(fracMatch[1]), parseInt(fracMatch[2]));
                const color = parseColorInput(fracMatch[3]);
                if (color) {
                    // Convert color to FractionColor and multiply
                    const fracColor = new FractionColor(color.r, color.y, color.b);
                    const result = fracColor.multiply(multiplier);
                    return result;
                }
            }

            // Check for decimal multiplier (e.g., "2 Blue", "0.5 Red")
            const multMatch = term.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
            if (multMatch) {
                const multiplier = Fraction.fromDecimal(parseFloat(multMatch[1]));
                const color = parseColorInput(multMatch[2]);
                if (color) {
                    // Convert color to FractionColor and multiply
                    const fracColor = new FractionColor(color.r, color.y, color.b);
                    const result = fracColor.multiply(multiplier);
                    return result;
                }
            }

            // No multiplier - just parse the color
            const color = parseColorInput(term);
            if (color) {
                return new FractionColor(color.r, color.y, color.b);
            }
            
            return null;
        }

        function addColors(c1, c2) {
            // FractionColor addition using fraction arithmetic
            return c1.add(c2);
        }

        function subtractColors(from, subtract) {
            // Calculate the total mass of each color
            const fromMass = from.r.add(from.y).add(from.b);
            const subtractMass = subtract.r.add(subtract.y).add(subtract.b);
            
            // Calculate the total mass after subtraction
            const totalMass = fromMass.add(subtractMass);
            
            // Calculate the fraction to remove: subtractMass / totalMass
            const fractionToRemove = subtractMass.divide(totalMass);
            
            // Expand 'from' color by multiplying by totalMass/fromMass
            const expansionFactor = totalMass.divide(fromMass);
            const expanded = from.multiply(expansionFactor);
            
            // Calculate mass to remove from each component
            // This should match the composition of 'subtract'
            const subtractNormMass = subtract.r.add(subtract.y).add(subtract.b);
            
            // For each component, remove proportional amount
            const toRemoveR = subtract.r.divide(subtractNormMass).multiply(fractionToRemove).multiply(totalMass);
            const toRemoveY = subtract.y.divide(subtractNormMass).multiply(fractionToRemove).multiply(totalMass);
            const toRemoveB = subtract.b.divide(subtractNormMass).multiply(fractionToRemove).multiply(totalMass);
            
            // Check if we have enough of each component
            const resultR = expanded.r.subtract(toRemoveR);
            const resultY = expanded.y.subtract(toRemoveY);
            const resultB = expanded.b.subtract(toRemoveB);
            
            // Check for negative results
            if (resultR.num < 0 || resultY.num < 0 || resultB.num < 0) {
                return { error: 'NOT POSSIBLE - insufficient color to subtract' };
            }
            
            return new FractionColor(resultR, resultY, resultB);
        }

        function identifyColor(fracColor) {
            // Convert FractionColor to simple ratio
            const simplified = fracColor.toRatio();

            // Check for exact match
            for (let name in colors) {
                const c = colors[name];
                if (c.r === simplified.r && c.y === simplified.y && c.b === simplified.b) {
                    return { name, level: c.level, ...simplified };
                }
            }

            // Custom color naming system
            return identifyCustomColor(simplified.r, simplified.y, simplified.b);
        }

        function findClosestColor(r, y, b) {
            let closest = null;
            let minDistance = Infinity;

            for (let name in colors) {
                const c = colors[name];
                const distance = Math.sqrt(
                    Math.pow(c.r - r, 2) +
                    Math.pow(c.y - y, 2) +
                    Math.pow(c.b - b, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = name;
                }
            }

            return closest;
        }

        function identifyCustomColor(r, y, b) {
            // Check if color contains brown (equal parts R, Y, B)
            const minComponent = Math.min(r, y, b);

            if (minComponent > 0) {
                // Contains brown
                const brownMass = minComponent * 3; // Brown is [1,1,1]
                const leftoverR = r - minComponent;
                const leftoverY = y - minComponent;
                const leftoverB = b - minComponent;
                const leftoverMass = leftoverR + leftoverY + leftoverB;

                if (leftoverMass === 0) {
                    // Pure brown
                    return { name: 'Brown', level: 'Brown', r, y, b };
                }

                // Find the closest color to the leftover
                const leftoverColorName = findClosestColor(leftoverR, leftoverY, leftoverB);

                // Determine naming based on mass comparison
                if (leftoverMass > brownMass) {
                    // More leftover than brown: "brownish-Color"
                    return { name: `Brownish-${leftoverColorName}`, level: 'Custom', r, y, b };
                } else if (leftoverMass === brownMass) {
                    // Equal: "Color-Brown"
                    return { name: `${leftoverColorName}-Brown`, level: 'Custom', r, y, b };
                } else {
                    // More brown than leftover
                    if (brownMass >= 2 * leftoverMass) {
                        // At least 2x brown: "Shade of Brown"
                        return { name: `Shade of Brown`, level: 'Custom', r, y, b };
                    } else {
                        // Less than 2x: "Colorish-Brown"
                        return { name: `${leftoverColorName}ish-Brown`, level: 'Custom', r, y, b };
                    }
                }
            }

            // No brown - find base color (highest mass component or combination)
            // First, check if this is close to a primary color
            const total = r + y + b;

            // Try to find the dominant color(s)
            // Find all named colors and see which has the highest "mass" in this color
            let maxMass = 0;
            let baseColor = null;

            for (let name in colors) {
                const c = colors[name];
                // Calculate how many "units" of this color fit into our color
                if (c.r === 0 && c.y === 0 && c.b === 0) continue;

                const maxUnits = Math.min(
                    c.r > 0 ? r / c.r : Infinity,
                    c.y > 0 ? y / c.y : Infinity,
                    c.b > 0 ? b / c.b : Infinity
                );

                if (maxUnits > 0) {
                    const mass = maxUnits * (c.r + c.y + c.b);
                    if (mass > maxMass) {
                        maxMass = mass;
                        baseColor = name;
                    }
                }
            }

            if (baseColor) {
                const c = colors[baseColor];
                const units = Math.min(
                    c.r > 0 ? r / c.r : Infinity,
                    c.y > 0 ? y / c.y : Infinity,
                    c.b > 0 ? b / c.b : Infinity
                );

                const baseMass = units * (c.r + c.y + c.b);
                const leftoverR = r - units * c.r;
                const leftoverY = y - units * c.y;
                const leftoverB = b - units * c.b;
                const leftoverMass = leftoverR + leftoverY + leftoverB;

                if (leftoverMass < 0.001) {
                    // Essentially pure base color (shouldn't happen as we check exact matches earlier)
                    return { name: baseColor, level: 'Custom', r, y, b };
                }

                // Find closest color to the leftover
                const modifierColorName = findClosestColor(leftoverR, leftoverY, leftoverB);

                // Determine naming based on mass comparison
                if (leftoverMass > baseMass) {
                    // More modifier than base: "baseish-Modifier"
                    return { name: `${baseColor}ish-${modifierColorName}`, level: 'Custom', r, y, b };
                } else if (leftoverMass === baseMass) {
                    // Equal: "Modifier-Base"
                    return { name: `${modifierColorName}-${baseColor}`, level: 'Custom', r, y, b };
                } else {
                    // More base than modifier
                    if (baseMass >= 2 * leftoverMass) {
                        // At least 2x base: "Shade of Base"
                        return { name: `Shade of ${baseColor}`, level: 'Custom', r, y, b };
                    } else {
                        // Less than 2x: "Modifierish-Base"
                        return { name: `${modifierColorName}ish-${baseColor}`, level: 'Custom', r, y, b };
                    }
                }
            }

            // Fallback to closest match
            const closest = findClosestColor(r, y, b);
            return {
                name: `Shade of ${closest}`,
                level: 'Custom',
                r, y, b
            };
        }

        function displayResult(container, result) {
            if (result.error) {
                container.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>${result.error}</p>
                    </div>
                `;
                return;
            }

            const rgb = rybToRgb(result.r, result.y, result.b);
            const hex = rgbToHex(rgb);

            container.innerHTML = `
                <div class="result">
                    <h3>Result</h3>
                    <div class="color-display">
                        <div class="color-swatch" style="background-color: ${hex};"></div>
                        <div class="color-info">
                            <p><strong>${result.name}</strong></p>
                            <p>Level: ${result.level}</p>
                            <p>Coordinates: [${result.r}, ${result.y}, ${result.b}]</p>
                            <p>RGB: ${hex}</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function processOperation() {
            const input = document.getElementById('mixInput').value;
            const result = document.getElementById('mixResult');

            if (!input.trim()) {
                result.innerHTML = '';
                return;
            }

            const operations = parseOperation(input);
            if (!operations) {
                result.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>Invalid input. Please check your color names or coordinates.</p>
                        <p>Examples: "Blue + Red", "[1,0,1] + [0,0,1]", "Brown", "Persimmon-Orange"</p>
                    </div>
                `;
                return;
            }

            // Check if first color has an error
            if (operations[0].color.error) {
                result.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>${operations[0].color.error}</p>
                    </div>
                `;
                return;
            }

            // If only one term, it's a lookup
            if (operations.length === 1) {
                const color = operations[0].color;
                const identified = identifyColor(color);
                displayResult(result, identified);
                return;
            }

            // Process operations left to right
            let currentColor = operations[0].color;

            for (let i = 1; i < operations.length; i += 2) {
                const operator = operations[i];
                const nextColor = operations[i + 1].color;

                // Check for errors in the next color
                if (nextColor.error) {
                    result.innerHTML = `
                        <div class="result error">
                            <h3>Error</h3>
                            <p>${nextColor.error}</p>
                        </div>
                    `;
                    return;
                }

                if (operator.operator === 'add') {
                    currentColor = addColors(currentColor, nextColor);
                } else {
                    currentColor = subtractColors(currentColor, nextColor);
                    if (currentColor.error) {
                        displayResult(result, currentColor);
                        return;
                    }
                }
            }

            // Identify the final color
            const finalResult = identifyColor(currentColor);
            displayResult(result, finalResult);
        }

        function clearMix() {
            document.getElementById('mixInput').value = '';
            document.getElementById('mixResult').innerHTML = '';
        }

        function showColorModal(name, colorData) {
            const modal = document.getElementById('colorModal');
            const modalContent = document.getElementById('modalColorDetails');

            const rgb = rybToRgb(colorData.r, colorData.y, colorData.b);
            const hex = rgbToHex(rgb);

            modalContent.innerHTML = `
                <div class="color-display">
                    <div class="color-swatch" style="background-color: ${hex};"></div>
                    <div class="color-info">
                        <p><strong>${name}</strong></p>
                        <p>Level: ${colorData.level}</p>
                        <p>Coordinates: [${colorData.r}, ${colorData.y}, ${colorData.b}]</p>
                        <p>RGB: ${hex}</p>
                    </div>
                </div>
            `;

            modal.classList.add('active');
        }

        function closeColorModal() {
            const modal = document.getElementById('colorModal');
            modal.classList.remove('active');
        }

        function populateReference() {
            const container = document.getElementById('colorReference');
            const levels = ['Primary', 'Secondary', 'Tertiary', 'Quaternary', 'Quinary', 'Brown'];

            let html = '';
            levels.forEach(level => {
                const levelColors = Object.entries(colors).filter(([_, c]) => c.level === level);
                if (levelColors.length > 0) {
                    // For Brown, just show "Brown" without count
                    const header = level === 'Brown' ? level : `${level} Colors (${levelColors.length})`;
                    html += `<h3 style="margin-top: 20px; margin-bottom: 10px; color: #667eea;">${header}</h3>`;
                    html += '<div class="color-grid">';
                    levelColors.forEach(([name, c]) => {
                        const rgb = rybToRgb(c.r, c.y, c.b);
                        const hex = rgbToHex(rgb);
                        html += `
                            <div class="color-card" onclick="showColorModal('${name}', ${JSON.stringify(c).replace(/"/g, '&quot;')})">
                                <div class="color-card-header">
                                    <div class="color-card-swatch" style="background-color: ${hex};"></div>
                                    <div class="color-card-name">${name}</div>
                                </div>
                                <div class="color-card-coord">[${c.r}, ${c.y}, ${c.b}]</div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
            });

            container.innerHTML = html;
        }

        // Initialize
        populateReference();

        // Allow Enter key to submit
        document.getElementById('mixInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') processOperation();
        });

        // Close modal when clicking outside
        document.getElementById('colorModal').addEventListener('click', (e) => {
            if (e.target.id === 'colorModal') {
                closeColorModal();
            }
        });
    </script>
</body>
</html>
