<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Color Mixer - RYB Color Theory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .result {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 2px solid #667eea;
        }

        .result h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .color-swatch {
            width: 100px;
            height: 100px;
            border-radius: 8px;
            border: 3px solid #333;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .color-info {
            flex: 1;
        }

        .color-info p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            border-color: #dc3545;
        }

        .success {
            color: #28a745;
        }

        .reference {
            grid-column: 1 / -1;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .color-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s;
        }

        .color-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .color-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .color-card-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #333;
        }

        .color-card-name {
            font-weight: bold;
            color: #333;
        }

        .color-card-coord {
            color: #666;
            font-size: 0.9em;
        }

        .help-text {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            color: #004085;
            font-size: 0.95em;
        }

        .help-text strong {
            display: block;
            margin-bottom: 5px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .reference {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸŽ¨ Paint Color Mixer</h1>
            <p>Mix colors using RYB (Red-Yellow-Blue) Color Theory</p>
        </header>

        <div class="main-content">
            <div class="section">
                <h2>Mix Colors</h2>
                <div class="help-text">
                    <strong>Examples:</strong>
                    Blue + Red<br>
                    2 Blue + 1 Violet<br>
                    Blue + Blue + Blue + Red<br>
                    Red + Yellow + Blue (= Brown)<br>
                    Purple - Blue<br>
                    Violet - 2 Blue
                </div>
                <div class="input-group">
                    <label for="mixInput">Enter color operation (supports multiple + and -):</label>
                    <input type="text" id="mixInput" placeholder="e.g., Blue + Red or Blue + Blue + Red">
                </div>
                <div class="button-group">
                    <button onclick="processOperation()">Calculate</button>
                    <button onclick="clearMix()">Clear</button>
                </div>
                <div id="mixResult"></div>
            </div>

            <div class="section">
                <h2>Lookup Color</h2>
                <div class="help-text">
                    <strong>Examples:</strong>
                    Purple<br>
                    [1,0,1] or 1,0,1<br>
                    [1R, 0Y, 1B]
                </div>
                <div class="input-group">
                    <label for="lookupInput">Enter color name or coordinates [R,Y,B]:</label>
                    <input type="text" id="lookupInput" placeholder="e.g., Purple or [1,0,1]">
                </div>
                <div class="button-group">
                    <button onclick="lookupColor()">Lookup</button>
                    <button onclick="clearLookup()">Clear</button>
                </div>
                <div id="lookupResult"></div>
            </div>

            <div class="section reference">
                <h2>Color Reference Guide</h2>
                <div id="colorReference"></div>
            </div>
        </div>
    </div>

    <script>
        // Define the complete color system (Wikipedia RYB standard)
        const colors = {
            // Primary (3)
            'Red': { r: 1, y: 0, b: 0, level: 'Primary' },
            'Yellow': { r: 0, y: 1, b: 0, level: 'Primary' },
            'Blue': { r: 0, y: 0, b: 1, level: 'Primary' },

            // Secondary (4)
            'Orange': { r: 1, y: 1, b: 0, level: 'Secondary' },
            'Green': { r: 0, y: 1, b: 1, level: 'Secondary' },
            'Purple': { r: 1, y: 0, b: 1, level: 'Secondary' },
            'Brown': { r: 1, y: 1, b: 1, level: 'Secondary' },

            // Tertiary (6) - Wikipedia standard
            'Vermilion': { r: 3, y: 1, b: 0, level: 'Tertiary' },
            'Amber': { r: 1, y: 3, b: 0, level: 'Tertiary' },
            'Chartreuse': { r: 0, y: 3, b: 1, level: 'Tertiary' },
            'Teal': { r: 0, y: 1, b: 3, level: 'Tertiary' },
            'Violet': { r: 1, y: 0, b: 3, level: 'Tertiary' },
            'Magenta': { r: 3, y: 0, b: 1, level: 'Tertiary' },

            // Quaternary (12) - Wikipedia standard
            'Scarlet': { r: 7, y: 1, b: 0, level: 'Quaternary' },
            'Persimmon': { r: 5, y: 3, b: 0, level: 'Quaternary' },
            'Sun': { r: 3, y: 5, b: 0, level: 'Quaternary' },
            'Golden': { r: 1, y: 7, b: 0, level: 'Quaternary' },
            'Lemon': { r: 0, y: 7, b: 1, level: 'Quaternary' },
            'Lime': { r: 0, y: 5, b: 3, level: 'Quaternary' },
            'Viridian': { r: 0, y: 3, b: 5, level: 'Quaternary' },
            'Cerulean': { r: 0, y: 1, b: 7, level: 'Quaternary' },
            'Indigo': { r: 1, y: 0, b: 7, level: 'Quaternary' },
            'Amethyst': { r: 3, y: 0, b: 5, level: 'Quaternary' },
            'Aubergine': { r: 5, y: 0, b: 3, level: 'Quaternary' },
            'Crimson': { r: 7, y: 0, b: 1, level: 'Quaternary' },

            // Quinary (24) - Descriptive hyphenated names
            'Red-Scarlet': { r: 15, y: 1, b: 0, level: 'Quinary' },
            'Scarlet-Vermilion': { r: 13, y: 3, b: 0, level: 'Quinary' },
            'Vermilion-Persimmon': { r: 11, y: 5, b: 0, level: 'Quinary' },
            'Persimmon-Orange': { r: 9, y: 7, b: 0, level: 'Quinary' },
            'Orange-Sun': { r: 7, y: 9, b: 0, level: 'Quinary' },
            'Sun-Amber': { r: 5, y: 11, b: 0, level: 'Quinary' },
            'Amber-Golden': { r: 3, y: 13, b: 0, level: 'Quinary' },
            'Golden-Yellow': { r: 1, y: 15, b: 0, level: 'Quinary' },
            'Yellow-Lemon': { r: 0, y: 15, b: 1, level: 'Quinary' },
            'Lemon-Chartreuse': { r: 0, y: 13, b: 3, level: 'Quinary' },
            'Chartreuse-Lime': { r: 0, y: 11, b: 5, level: 'Quinary' },
            'Lime-Green': { r: 0, y: 9, b: 7, level: 'Quinary' },
            'Green-Viridian': { r: 0, y: 7, b: 9, level: 'Quinary' },
            'Viridian-Teal': { r: 0, y: 5, b: 11, level: 'Quinary' },
            'Teal-Cerulean': { r: 0, y: 3, b: 13, level: 'Quinary' },
            'Cerulean-Blue': { r: 0, y: 1, b: 15, level: 'Quinary' },
            'Blue-Indigo': { r: 1, y: 0, b: 15, level: 'Quinary' },
            'Indigo-Violet': { r: 3, y: 0, b: 13, level: 'Quinary' },
            'Violet-Amethyst': { r: 5, y: 0, b: 11, level: 'Quinary' },
            'Amethyst-Purple': { r: 7, y: 0, b: 9, level: 'Quinary' },
            'Purple-Aubergine': { r: 9, y: 0, b: 7, level: 'Quinary' },
            'Aubergine-Magenta': { r: 11, y: 0, b: 5, level: 'Quinary' },
            'Magenta-Crimson': { r: 13, y: 0, b: 3, level: 'Quinary' },
            'Crimson-Red': { r: 15, y: 0, b: 1, level: 'Quinary' }
        };

        // RYB to RGB conversion (takes Red, Yellow, Blue values)
        function rybToRgb(r, y, b) {
            const total = r + y + b;
            if (total === 0) return { r: 128, g: 128, b: 128 };

            // Normalize
            const rn = r / total;
            const yn = y / total;
            const bn = b / total;

            // RYB to RGB conversion matrix (approximation)
            const rgb_r = Math.round(255 * (rn + yn * 0.5 + bn * 0.1));
            const rgb_g = Math.round(255 * (yn + bn * 0.5 + rn * 0.1));
            const rgb_b = Math.round(255 * (bn + rn * 0.3));

            return {
                r: Math.min(255, Math.max(0, rgb_r)),
                g: Math.min(255, Math.max(0, rgb_g)),
                b: Math.min(255, Math.max(0, rgb_b))
            };
        }

        function rgbToHex(rgb) {
            return '#' + [rgb.r, rgb.g, rgb.b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function simplifyRatio(r, y, b) {
            const divisor = gcd(gcd(r, y), b);
            return {
                r: r / divisor,
                y: y / divisor,
                b: b / divisor
            };
        }

        function parseColorInput(input) {
            input = input.trim();

            // Check if it's a color name
            for (let name in colors) {
                if (name.toLowerCase() === input.toLowerCase()) {
                    return { ...colors[name], name };
                }
            }

            // Check if it's coordinates [r,y,b]
            const coordMatch = input.match(/\[?\s*(\d+)[,\s]+(\d+)[,\s]+(\d+)\s*\]?/);
            if (coordMatch) {
                const r = parseInt(coordMatch[1]);
                const y = parseInt(coordMatch[2]);
                const b = parseInt(coordMatch[3]);
                return { r, y, b };
            }

            // Check for [XR, YY, ZB] format
            const labeledMatch = input.match(/\[?\s*(\d+)\s*R[,\s]+(\d+)\s*Y[,\s]+(\d+)\s*B\s*\]?/i);
            if (labeledMatch) {
                return {
                    r: parseInt(labeledMatch[1]),
                    y: parseInt(labeledMatch[2]),
                    b: parseInt(labeledMatch[3])
                };
            }

            return null;
        }

        function parseOperation(input) {
            input = input.trim();

            // Split by + and - while preserving the operators
            const tokens = [];
            let currentTerm = '';
            let inBrackets = 0;

            for (let i = 0; i < input.length; i++) {
                const char = input[i];

                if (char === '[') inBrackets++;
                if (char === ']') inBrackets--;

                if ((char === '+' || char === '-') && inBrackets === 0 && i > 0) {
                    // Found an operator outside brackets
                    tokens.push({ type: 'term', value: currentTerm.trim() });
                    tokens.push({ type: 'operator', value: char });
                    currentTerm = '';
                } else {
                    currentTerm += char;
                }
            }

            // Add the last term
            if (currentTerm.trim()) {
                tokens.push({ type: 'term', value: currentTerm.trim() });
            }

            // Must have at least one term and one operator
            if (tokens.length < 3) {
                return null;
            }

            // Parse all color terms
            const operations = [];
            for (let i = 0; i < tokens.length; i++) {
                if (tokens[i].type === 'term') {
                    const color = parseColorTerm(tokens[i].value);
                    if (!color) return null;
                    operations.push({ type: 'color', color });
                } else if (tokens[i].type === 'operator') {
                    operations.push({
                        type: 'operator',
                        operator: tokens[i].value === '+' ? 'add' : 'subtract'
                    });
                }
            }

            return operations;
        }

        function parseColorTerm(term) {
            term = term.trim();

            // Check for multiplier (e.g., "2 Blue")
            const multMatch = term.match(/^(\d+)\s+(.+)$/);
            if (multMatch) {
                const multiplier = parseInt(multMatch[1]);
                const color = parseColorInput(multMatch[2]);
                if (color) {
                    return {
                        b: color.b * multiplier,
                        r: color.r * multiplier,
                        y: color.y * multiplier
                    };
                }
            }

            return parseColorInput(term);
        }

        function addColors(c1, c2) {
            // Use total mass (sum of coordinates) to determine amount of paint
            // This correctly handles both user input and intermediate results
            const mass1 = c1.r + c1.y + c1.b;
            const mass2 = c2.r + c2.y + c2.b;

            // Normalize each color by its total mass to get composition per unit
            const norm1_r = mass1 > 0 ? c1.r / mass1 : 0;
            const norm1_y = mass1 > 0 ? c1.y / mass1 : 0;
            const norm1_b = mass1 > 0 ? c1.b / mass1 : 0;

            const norm2_r = mass2 > 0 ? c2.r / mass2 : 0;
            const norm2_y = mass2 > 0 ? c2.y / mass2 : 0;
            const norm2_b = mass2 > 0 ? c2.b / mass2 : 0;

            // Each color contributes: mass Ã— normalized_composition
            // This gives equal weight to each color by mass
            const contrib1_r = mass1 * norm1_r;
            const contrib1_y = mass1 * norm1_y;
            const contrib1_b = mass1 * norm1_b;

            const contrib2_r = mass2 * norm2_r;
            const contrib2_y = mass2 * norm2_y;
            const contrib2_b = mass2 * norm2_b;

            // Add contributions
            return {
                r: contrib1_r + contrib2_r,
                y: contrib1_y + contrib2_y,
                b: contrib1_b + contrib2_b
            };
        }

        function subtractColors(from, subtract) {
            // Extract number of parts using GCD
            const partsFrom = gcd(gcd(from.r, from.y), from.b) || 1;
            const partsSubtract = gcd(gcd(subtract.r, subtract.y), subtract.b) || 1;

            // Total parts in the mixture
            const totalParts = partsFrom + partsSubtract;

            // Get base composition by dividing by parts
            const baseFrom_r = from.r / partsFrom;
            const baseFrom_y = from.y / partsFrom;
            const baseFrom_b = from.b / partsFrom;

            const baseSubtract_r = subtract.r / partsSubtract;
            const baseSubtract_y = subtract.y / partsSubtract;
            const baseSubtract_b = subtract.b / partsSubtract;

            // Expand 'from' color by multiplying base by total parts
            const expanded = {
                r: baseFrom_r * totalParts,
                y: baseFrom_y * totalParts,
                b: baseFrom_b * totalParts
            };

            // Calculate m% = parts being removed / total parts
            const m_percent = partsSubtract / totalParts;

            // Calculate total mass of expanded color
            const totalMass = expanded.r + expanded.y + expanded.b;

            // Calculate mass to remove: m% of total mass, with composition matching what we're subtracting
            const massToRemove = m_percent * totalMass;
            const baseTotalSubtract = baseSubtract_r + baseSubtract_y + baseSubtract_b;

            // Check if we have enough of each component to remove what's needed
            const checks = [];
            if (baseSubtract_r > 0) {
                const amountToRemove = (baseSubtract_r / baseTotalSubtract) * massToRemove;
                checks.push({
                    color: 'Red',
                    needed: amountToRemove,
                    available: expanded.r,
                    ok: expanded.r >= amountToRemove - 0.0001  // small epsilon for floating point
                });
            }
            if (baseSubtract_y > 0) {
                const amountToRemove = (baseSubtract_y / baseTotalSubtract) * massToRemove;
                checks.push({
                    color: 'Yellow',
                    needed: amountToRemove,
                    available: expanded.y,
                    ok: expanded.y >= amountToRemove - 0.0001
                });
            }
            if (baseSubtract_b > 0) {
                const amountToRemove = (baseSubtract_b / baseTotalSubtract) * massToRemove;
                checks.push({
                    color: 'Blue',
                    needed: amountToRemove,
                    available: expanded.b,
                    ok: expanded.b >= amountToRemove - 0.0001
                });
            }

            const allOk = checks.every(c => c.ok);
            if (!allOk) {
                return { error: 'NOT POSSIBLE - insufficient color to subtract' };
            }

            // Remove mass with same composition as 'subtract'
            const result = {
                r: expanded.r - (massToRemove * baseSubtract_r / baseTotalSubtract),
                y: expanded.y - (massToRemove * baseSubtract_y / baseTotalSubtract),
                b: expanded.b - (massToRemove * baseSubtract_b / baseTotalSubtract)
            };

            return simplifyRatio(result.r, result.y, result.b);
        }

        function identifyColor(r, y, b) {
            const simplified = simplifyRatio(r, y, b);

            // Check for exact match
            for (let name in colors) {
                const c = colors[name];
                if (c.r === simplified.r && c.y === simplified.y && c.b === simplified.b) {
                    return { name, level: c.level, ...simplified };
                }
            }

            // Find closest match
            let closest = null;
            let minDistance = Infinity;

            for (let name in colors) {
                const c = colors[name];
                const distance = Math.sqrt(
                    Math.pow(c.r - simplified.r, 2) +
                    Math.pow(c.y - simplified.y, 2) +
                    Math.pow(c.b - simplified.b, 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = name;
                }
            }

            return {
                name: `Shade of ${closest}`,
                level: 'Custom',
                ...simplified
            };
        }

        function displayResult(container, result) {
            if (result.error) {
                container.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>${result.error}</p>
                    </div>
                `;
                return;
            }

            const rgb = rybToRgb(result.r, result.y, result.b);
            const hex = rgbToHex(rgb);

            container.innerHTML = `
                <div class="result">
                    <h3>Result</h3>
                    <div class="color-display">
                        <div class="color-swatch" style="background-color: ${hex};"></div>
                        <div class="color-info">
                            <p><strong>${result.name}</strong></p>
                            <p>Level: ${result.level}</p>
                            <p>Coordinates: [${result.r}, ${result.y}, ${result.b}]</p>
                            <p>RGB: ${hex}</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function processOperation() {
            const input = document.getElementById('mixInput').value;
            const result = document.getElementById('mixResult');

            const operations = parseOperation(input);
            if (!operations) {
                result.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>Invalid operation. Use format: "Blue + Red" or "Blue + Blue + Red"</p>
                    </div>
                `;
                return;
            }

            // Process operations left to right
            let currentColor = operations[0].color;

            for (let i = 1; i < operations.length; i += 2) {
                const operator = operations[i];
                const nextColor = operations[i + 1].color;

                if (operator.operator === 'add') {
                    currentColor = addColors(currentColor, nextColor);
                } else {
                    currentColor = subtractColors(currentColor, nextColor);
                    if (currentColor.error) {
                        displayResult(result, currentColor);
                        return;
                    }
                }
            }

            // Identify the final color
            const finalResult = identifyColor(currentColor.r, currentColor.y, currentColor.b);
            displayResult(result, finalResult);
        }

        function lookupColor() {
            const input = document.getElementById('lookupInput').value;
            const result = document.getElementById('lookupResult');

            const color = parseColorInput(input);
            if (!color) {
                result.innerHTML = `
                    <div class="result error">
                        <h3>Error</h3>
                        <p>Invalid color. Use a color name or coordinates like [1,0,1] in [R,Y,B] format</p>
                    </div>
                `;
                return;
            }

            const identified = identifyColor(color.r, color.y, color.b);
            displayResult(result, identified);
        }

        function clearMix() {
            document.getElementById('mixInput').value = '';
            document.getElementById('mixResult').innerHTML = '';
        }

        function clearLookup() {
            document.getElementById('lookupInput').value = '';
            document.getElementById('lookupResult').innerHTML = '';
        }

        function populateReference() {
            const container = document.getElementById('colorReference');
            const levels = ['Primary', 'Secondary', 'Tertiary', 'Quaternary', 'Quinary'];

            let html = '';
            levels.forEach(level => {
                const levelColors = Object.entries(colors).filter(([_, c]) => c.level === level);
                if (levelColors.length > 0) {
                    html += `<h3 style="margin-top: 20px; margin-bottom: 10px; color: #667eea;">${level} Colors (${levelColors.length})</h3>`;
                    html += '<div class="color-grid">';
                    levelColors.forEach(([name, c]) => {
                        const rgb = rybToRgb(c.r, c.y, c.b);
                        const hex = rgbToHex(rgb);
                        html += `
                            <div class="color-card">
                                <div class="color-card-header">
                                    <div class="color-card-swatch" style="background-color: ${hex};"></div>
                                    <div class="color-card-name">${name}</div>
                                </div>
                                <div class="color-card-coord">[${c.r}, ${c.y}, ${c.b}]</div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
            });

            container.innerHTML = html;
        }

        // Initialize
        populateReference();

        // Allow Enter key to submit
        document.getElementById('mixInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') processOperation();
        });
        document.getElementById('lookupInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') lookupColor();
        });
    </script>
</body>
</html>
