This code is was designed for Ulysses to run on his TI-84 Plus CE calculator.

This is similar to CNT_FLP2; the difference is that rather than flipping only the last 2 digits, ALL digits are flipped. So, compute 2^n, say the number, flip (if possible), compute 2^(n+1), say the number, flip (if possible), continue.

Ex. 1,2,4,8,16,61,32,23,64,46,128,821,...


The output displays the number of numbers that have been counted/displayed (on the left) and the value of the nth number counted (on the right)
Ex:
0: val_{0}
1: val_{1}
2: val_{2}
3: val_{3}
.
.
.
n: val_{n}

And terminates when n exceeds some hard-coded value or val_{n} exceeds an input value.


To run:
1. At prompt "Enter max value:" enter the value counting will start at then press Enter.
2. Press Enter when prompted.


Example 1:

Enter max value:
1000

0: 1
1: 2
2: 4
3: 8
4: 16
5: 61
6: 32
7: 23
8: 64
9: 46
10: 128
11: 821
12: 256
13: 652
14: 512
15: 215
16: 1024
Done!
Try again sometime!







NOTES:









Summary:


Name:
    CNT_FLIP.py

Version:
    wessler
    2025 December 7
    1st version

Description:
    *designed to run on Ulee's TI-84 Plus CE
    *counts by 2^n, but first says the number then flips all digits of the number and says it again (iff the flipped number is different from the unflipped).
    *Similar to CNT_FLP2.py, which was the predecessor.

Inputs:
    *NOTHING
    *(does have user input values when prompted)

Outputs/does:

        Enter:
            *max_value
        Output:
            0: 0
            1: 2
            2: 4
            .
            .
            .
            i: j

            it ends when either i==max_number_of_numbers (hard-coded) or j>=max_value

Used by:
    *NOTHING--this is standalone code

Uses:
    *NOTHING--this is standalone code

NOTES:

because this is exponential, it gets big very fast.

this pattern (flipping all digits) can be used for other counting methods (other than 2^n), but Ulee did it with 2^n when making it up, so that's what this script is based on. Obviously, the algorithm can easily be repurposed for other counting methods.

